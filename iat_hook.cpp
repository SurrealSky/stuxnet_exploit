#include "include.h"
#include<vector>

bool hookIAT(char moduleName[],char libName[], std::vector<HookOne> hookfunclist) 
{
	DWORD_PTR  imageBase = (DWORD_PTR)GetModuleHandleA(moduleName);
	PIMAGE_DOS_HEADER dosHeaders = (PIMAGE_DOS_HEADER)imageBase;
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(imageBase + dosHeaders->e_lfanew);
	IMAGE_OPTIONAL_HEADER optionalHeader = ntHeaders->OptionalHeader;
	PIMAGE_IMPORT_DESCRIPTOR importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)(imageBase + optionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);


	DWORD oldProtect;
	PIMAGE_IMPORT_BY_NAME functionName;
	PIMAGE_THUNK_DATA originalFirstThunk = NULL, firstThunk = NULL;
	/*
	Initially FirstThunk is the same as OriginalFirstThunk
	The OriginalFirstThunk is array of names ---> Uses the AddressOfData element of the IMAGE_THUNK_DATA structure to point to IMAGE_IMPORT_BY_NAME structure that contains the Name element, function name.
	The FirstThunk is array of addresses -------> Uses the Function element of the IMAGE_THUNK_DATA structure, which points to the address of the imported function.

	When the executable is loaded, the loader goes through the OriginalFirstThunk array and finds all imported function names the executable is using.
	Then it calculates the addresses of the functions and populates the FirstThunk array so that real functions can be accessed.
	As a result, we need to change the real loaded addresses which are found in FirstThunk not in OriginalFirstThunk
	*/

	//LoadLibraryA(libName);
	while (importDescriptor->Name) {
		//判断导入库是否是目标库
		if (_strnicmp(libName, (LPCSTR)(imageBase + importDescriptor->Name), strlen(libName)) != 0) {
			importDescriptor++;
			continue;
		}

		originalFirstThunk = (PIMAGE_THUNK_DATA)(imageBase + importDescriptor->OriginalFirstThunk);
		firstThunk = (PIMAGE_THUNK_DATA)(imageBase + importDescriptor->FirstThunk);

		bool isAllHook = true;
		while (originalFirstThunk->u1.AddressOfData) 
		{
			//对导入表函数进行遍历
			functionName = (PIMAGE_IMPORT_BY_NAME)(imageBase + originalFirstThunk->u1.AddressOfData);
			std::vector<HookOne>::iterator iter = hookfunclist.begin();
			for (; iter != hookfunclist.end(); iter++)
			{
				if (strcmp((char*)functionName->Name, iter->API_Name.c_str()) == 0) 
				{
					OutputDebugStringA((char*)functionName->Name);
					//此处需要读写，执行权限，其粒度是4k，没有execute权限，可能会导致其它地方代码区域不可执行
					VirtualProtect((LPVOID)(&firstThunk->u1.Function), sizeof(DWORD_PTR), PAGE_EXECUTE_READWRITE, &oldProtect);
					firstThunk->u1.Function = (DWORD_PTR)iter->newFun;
					VirtualProtect((LPVOID)(&firstThunk->u1.Function), sizeof(DWORD_PTR), oldProtect, &oldProtect);
					iter->isHook = true;
				}
			}
			//if (hookfunclist[0].isHook && hookfunclist[1].isHook)
			//{
			//	//OutputDebugStringA("all hook end");
			//	break;
			//}
			originalFirstThunk++;
			firstThunk++;
		}
		return true;
	}
	return true;
}