#include"include.h"

bool check_target_info(TargetInfo &targetInfo)
{
	typedef LONG(__stdcall* fnRtlGetVersionEx)(LPOSVERSIONINFOEXA lpVersionInformation);
	fnRtlGetVersionEx pRtlGetVersion;
	HMODULE hNtdll;
	LONG ntStatus;
	ULONG    dwMajorVersion = 0;
	ULONG    dwMinorVersion = 0;
	ULONG    dwBuildNumber = 0;
	OSVERSIONINFOEXA VersionInformation = { 0 };

	hNtdll = GetModuleHandle(L"ntdll.dll");
	if (hNtdll == NULL) return false;
	pRtlGetVersion = (fnRtlGetVersionEx)GetProcAddress(hNtdll, "RtlGetVersion");
	if (pRtlGetVersion == NULL) return false;
	VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
	ntStatus = pRtlGetVersion(&VersionInformation);
	if (ntStatus != 0) return false;

	targetInfo.dwMajorVersion = VersionInformation.dwMajorVersion;
	targetInfo.dwMinorVersion = VersionInformation.dwMinorVersion;

	typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

	LPFN_ISWOW64PROCESS
		fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
			GetModuleHandle(L"kernel32.dll"), "IsWow64Process");
	if (NULL != fnIsWow64Process)
	{
		if (!fnIsWow64Process(GetCurrentProcess(), &targetInfo.bIsWow64))
		{
			return false;
		}
	}

    //https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-osversioninfoexa
}

bool check_admin()
{
	BOOL bElevated = FALSE;	//是否管理员
	//1.得到自身进程的权限访问令牌
	HANDLE hToken = NULL;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		return FALSE;
	//2.获取进程相关运行权限
	TOKEN_ELEVATION tokenEle;
	DWORD dwRetLen = 0;
	if (GetTokenInformation(hToken, TokenElevation, &tokenEle, sizeof(tokenEle), &dwRetLen)) 	
	{
		//如果接受到的内存大小和结构体成正比例，代表接受完整的进程权限数据
		if (dwRetLen == sizeof(tokenEle)) 	
		{ 
			//取是否管理员布尔值
			bElevated = tokenEle.TokenIsElevated; 
		}
	}   	
	//关闭进程令牌
	CloseHandle(hToken);  	
	//返回是否OK
	return bElevated;
}