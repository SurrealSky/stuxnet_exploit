#include "inject.h"
#include <iostream>
#include <stdarg.h>
#include <Windows.h>
#include <Psapi.h>
#include <stdint.h>
#include <tlhelp32.h>
#include <imagehlp.h>
#pragma comment(lib,"Psapi.lib")  //编译这个lib文件
#pragma comment(lib,"imagehlp.lib") 

bool injectDll(char sDllPath[], wchar_t run_path[])
{
    //启动目标进程
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    memset(&si, 0, sizeof(STARTUPINFO));
    memset(&pi, 0, sizeof(PROCESS_INFORMATION));
    si.cb = sizeof(STARTUPINFO);
    BOOL bRet = ::CreateProcess(run_path, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
    //获得进程入口
    HANDLE curProcessHandle = pi.hProcess; //获得当前进程的句柄
    // 创建虚拟内存地址，放置dll路径
    LPVOID pDllPath = VirtualAllocEx(curProcessHandle, NULL, strlen(sDllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (pDllPath == NULL)
    {
        OutputDebugString(L"VirtualAllocEx ERROR!");
        return false;
    }
    
    WriteProcessMemory(curProcessHandle, pDllPath, sDllPath, strlen(sDllPath) + 1, NULL);
    // 获取LoadLibraryA地址:用于注入dll;
    PTHREAD_START_ROUTINE pfnLoadLib = (PTHREAD_START_ROUTINE)GetProcAddress(
        GetModuleHandle(TEXT("kernel32")), "LoadLibraryA");
    // 在线程中执行dll中的入口函数：即导入dll
    HANDLE hNewThread = CreateRemoteThread(curProcessHandle, NULL, 0, pfnLoadLib, pDllPath, 0, NULL);
    // TODO: 后续可以插入命令行操作
    WaitForSingleObject(hNewThread, INFINITE);
    VirtualFreeEx(curProcessHandle, pDllPath, 0, MEM_RELEASE);
    CloseHandle(hNewThread);
    CloseHandle(curProcessHandle);
    //ResumeThread(pi.hThread);//继续
    return true;
}
